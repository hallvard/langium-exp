/******************************************************************************
 * This file was generated by langium-cli 3.5.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable */
import * as langium from 'langium';

export const SosiTerminals = {
    WS: /\s+/,
    ID: /[_a-zA-Z][\w_]*/,
    INT: /[0-9]+/,
    STRING: /"(\\.|[^"\\])*"|'(\\.|[^'\\])*'/,
    ML_COMMENT: /\/\*[\s\S]*?\*\//,
    SL_COMMENT: /\/\/[^\n\r]*/,
};

export type SosiTerminalNames = keyof typeof SosiTerminals;

export type SosiKeywordNames =
    | "#"
    | "*"
    | "+"
    | ","
    | "."
    | ".."
    | ":"
    | "?"
    | "@"
    | "["
    | "]"
    | "^"
    | "abstract"
    | "as"
    | "builtin"
    | "data"
    | "extends"
    | "feature"
    | "specification"
    | "type"
    | "{"
    | "}";

export type SosiTokenNames = SosiTerminalNames | SosiKeywordNames;

export type Multiplicity = OneOrMoreMultiplicity | SomeMultiplicity | ZeroOrMoreMultiplicity | ZeroOrOneMultiplicity;

export const Multiplicity = 'Multiplicity';

export function isMultiplicity(item: unknown): item is Multiplicity {
    return reflection.isInstance(item, Multiplicity);
}

export type Name = string;

export function isName(item: unknown): item is Name {
    return (typeof item === 'string' && (/[_a-zA-Z][\w_]*/.test(item) || /"(\\.|[^"\\])*"|'(\\.|[^'\\])*'/.test(item)));
}

export type PropertyKind = '#' | '@' | '^';

export function isPropertyKind(item: unknown): item is PropertyKind {
    return item === '@' || item === '#' || item === '^';
}

export type PropertyType = InlineType | TypeRef;

export const PropertyType = 'PropertyType';

export function isPropertyType(item: unknown): item is PropertyType {
    return reflection.isInstance(item, PropertyType);
}

export type QName = string;

export function isQName(item: unknown): item is QName {
    return typeof item === 'string';
}

export type Type = BuiltinType | CompositeType;

export const Type = 'Type';

export function isType(item: unknown): item is Type {
    return reflection.isInstance(item, Type);
}

export interface BuiltinType extends langium.AstNode {
    readonly $container: InlineType | Specification;
    readonly $type: 'BuiltinType';
    mappings: Array<DomainMapping>;
    name?: Name;
}

export const BuiltinType = 'BuiltinType';

export function isBuiltinType(item: unknown): item is BuiltinType {
    return reflection.isInstance(item, BuiltinType);
}

export interface CompositeType extends langium.AstNode {
    readonly $container: InlineType | Specification;
    readonly $type: 'CompositeType';
    description?: string;
    extends: Array<langium.Reference<Type>>;
    isAbstract: boolean;
    kind?: 'data' | 'feature';
    mappings: Array<DomainMapping>;
    name?: Name;
    properties: Array<Property>;
}

export const CompositeType = 'CompositeType';

export function isCompositeType(item: unknown): item is CompositeType {
    return reflection.isInstance(item, CompositeType);
}

export interface DomainMapping extends langium.AstNode {
    readonly $container: BuiltinType | CompositeType | Property;
    readonly $type: 'DomainMapping';
    domain: QName;
    target: QName | string;
}

export const DomainMapping = 'DomainMapping';

export function isDomainMapping(item: unknown): item is DomainMapping {
    return reflection.isInstance(item, DomainMapping);
}

export interface InlineType extends langium.AstNode {
    readonly $container: Property;
    readonly $type: 'InlineType';
    type: Type;
}

export const InlineType = 'InlineType';

export function isInlineType(item: unknown): item is InlineType {
    return reflection.isInstance(item, InlineType);
}

export interface OneOrMoreMultiplicity extends langium.AstNode {
    readonly $container: Property;
    readonly $type: 'OneOrMoreMultiplicity';
    spec: '+';
}

export const OneOrMoreMultiplicity = 'OneOrMoreMultiplicity';

export function isOneOrMoreMultiplicity(item: unknown): item is OneOrMoreMultiplicity {
    return reflection.isInstance(item, OneOrMoreMultiplicity);
}

export interface Property extends langium.AstNode {
    readonly $container: CompositeType;
    readonly $type: 'Property';
    description?: string;
    kind?: PropertyKind;
    mappings: Array<DomainMapping>;
    multiplicity?: Multiplicity;
    name: Name;
    type: PropertyType;
}

export const Property = 'Property';

export function isProperty(item: unknown): item is Property {
    return reflection.isInstance(item, Property);
}

export interface SomeMultiplicity extends langium.AstNode {
    readonly $container: Property;
    readonly $type: 'SomeMultiplicity';
    lower: '[';
    upper?: number;
}

export const SomeMultiplicity = 'SomeMultiplicity';

export function isSomeMultiplicity(item: unknown): item is SomeMultiplicity {
    return reflection.isInstance(item, SomeMultiplicity);
}

export interface Specification extends langium.AstNode {
    readonly $type: 'Specification';
    description?: string;
    name: QName;
    types: Array<Type>;
}

export const Specification = 'Specification';

export function isSpecification(item: unknown): item is Specification {
    return reflection.isInstance(item, Specification);
}

export interface TypeRef extends langium.AstNode {
    readonly $container: Property;
    readonly $type: 'TypeRef';
    typeRef: langium.Reference<Type>;
}

export const TypeRef = 'TypeRef';

export function isTypeRef(item: unknown): item is TypeRef {
    return reflection.isInstance(item, TypeRef);
}

export interface ZeroOrMoreMultiplicity extends langium.AstNode {
    readonly $container: Property;
    readonly $type: 'ZeroOrMoreMultiplicity';
    spec: '*';
}

export const ZeroOrMoreMultiplicity = 'ZeroOrMoreMultiplicity';

export function isZeroOrMoreMultiplicity(item: unknown): item is ZeroOrMoreMultiplicity {
    return reflection.isInstance(item, ZeroOrMoreMultiplicity);
}

export interface ZeroOrOneMultiplicity extends langium.AstNode {
    readonly $container: Property;
    readonly $type: 'ZeroOrOneMultiplicity';
    spec: '?';
}

export const ZeroOrOneMultiplicity = 'ZeroOrOneMultiplicity';

export function isZeroOrOneMultiplicity(item: unknown): item is ZeroOrOneMultiplicity {
    return reflection.isInstance(item, ZeroOrOneMultiplicity);
}

export type SosiAstType = {
    BuiltinType: BuiltinType
    CompositeType: CompositeType
    DomainMapping: DomainMapping
    InlineType: InlineType
    Multiplicity: Multiplicity
    OneOrMoreMultiplicity: OneOrMoreMultiplicity
    Property: Property
    PropertyType: PropertyType
    SomeMultiplicity: SomeMultiplicity
    Specification: Specification
    Type: Type
    TypeRef: TypeRef
    ZeroOrMoreMultiplicity: ZeroOrMoreMultiplicity
    ZeroOrOneMultiplicity: ZeroOrOneMultiplicity
}

export class SosiAstReflection extends langium.AbstractAstReflection {

    getAllTypes(): string[] {
        return [BuiltinType, CompositeType, DomainMapping, InlineType, Multiplicity, OneOrMoreMultiplicity, Property, PropertyType, SomeMultiplicity, Specification, Type, TypeRef, ZeroOrMoreMultiplicity, ZeroOrOneMultiplicity];
    }

    protected override computeIsSubtype(subtype: string, supertype: string): boolean {
        switch (subtype) {
            case BuiltinType:
            case CompositeType: {
                return this.isSubtype(Type, supertype);
            }
            case InlineType:
            case TypeRef: {
                return this.isSubtype(PropertyType, supertype);
            }
            case OneOrMoreMultiplicity:
            case SomeMultiplicity:
            case ZeroOrMoreMultiplicity:
            case ZeroOrOneMultiplicity: {
                return this.isSubtype(Multiplicity, supertype);
            }
            default: {
                return false;
            }
        }
    }

    getReferenceType(refInfo: langium.ReferenceInfo): string {
        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
        switch (referenceId) {
            case 'CompositeType:extends':
            case 'TypeRef:typeRef': {
                return Type;
            }
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }

    getTypeMetaData(type: string): langium.TypeMetaData {
        switch (type) {
            case BuiltinType: {
                return {
                    name: BuiltinType,
                    properties: [
                        { name: 'mappings', defaultValue: [] },
                        { name: 'name' }
                    ]
                };
            }
            case CompositeType: {
                return {
                    name: CompositeType,
                    properties: [
                        { name: 'description' },
                        { name: 'extends', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'kind' },
                        { name: 'mappings', defaultValue: [] },
                        { name: 'name' },
                        { name: 'properties', defaultValue: [] }
                    ]
                };
            }
            case DomainMapping: {
                return {
                    name: DomainMapping,
                    properties: [
                        { name: 'domain' },
                        { name: 'target' }
                    ]
                };
            }
            case InlineType: {
                return {
                    name: InlineType,
                    properties: [
                        { name: 'type' }
                    ]
                };
            }
            case OneOrMoreMultiplicity: {
                return {
                    name: OneOrMoreMultiplicity,
                    properties: [
                        { name: 'spec' }
                    ]
                };
            }
            case Property: {
                return {
                    name: Property,
                    properties: [
                        { name: 'description' },
                        { name: 'kind' },
                        { name: 'mappings', defaultValue: [] },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'type' }
                    ]
                };
            }
            case SomeMultiplicity: {
                return {
                    name: SomeMultiplicity,
                    properties: [
                        { name: 'lower' },
                        { name: 'upper' }
                    ]
                };
            }
            case Specification: {
                return {
                    name: Specification,
                    properties: [
                        { name: 'description' },
                        { name: 'name' },
                        { name: 'types', defaultValue: [] }
                    ]
                };
            }
            case TypeRef: {
                return {
                    name: TypeRef,
                    properties: [
                        { name: 'typeRef' }
                    ]
                };
            }
            case ZeroOrMoreMultiplicity: {
                return {
                    name: ZeroOrMoreMultiplicity,
                    properties: [
                        { name: 'spec' }
                    ]
                };
            }
            case ZeroOrOneMultiplicity: {
                return {
                    name: ZeroOrOneMultiplicity,
                    properties: [
                        { name: 'spec' }
                    ]
                };
            }
            default: {
                return {
                    name: type,
                    properties: []
                };
            }
        }
    }
}

export const reflection = new SosiAstReflection();
